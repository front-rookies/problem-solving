# 📌 문제 설명

**백준 12100번: 텀 2048(easy)**  
[문제 링크](https://www.acmicpc.net/problem/12100)

## 💡 접근 방법

- 단순 구현문제인데 게임의 규칙이 상당히 까다로웠던 문제
- 많이 틀리면서 반례 case와 비교하면서 로직을 수정해 나갔다.

## ✨ 해결 방법

1. **구현**

- 코드가 복잡할 수 밖에 없기 때문에 왼쪽으로 옮기는 방법만 살펴보도록 하자.
- 우선 temp로 합쳐질, 또는 막힐 위치의 인덱스를 표시한다. 초기위치는 0
- 오른쪽으로 반복문을 돌면서 순차적으로 살펴본다
- 우선 가장먼저 옮겨질 위치가 값이 0이면 무시하고 지나간다.
- 가장먼저 옮겨질 위치가 0이 아니면 temp와 합쳐지거나 막힐 것이다.
- 1. temp위치가 0이면 그냥 temp로 옮겨주고 자기자신은 0으로 변경한다.
- 2. temp위치가 0이 아니면 합쳐지거나 막힌다.
  - 합쳐지는 경우 : temp위치 값을 2배로 만들어 합치고 자기자신은 0으로 변경한다.
  - 막히는 경우 : temp의 + 1위치에 옮겨주면 된다. 여기서 주의해야 할 점이 있는데
    바로 옆에 있으면 상관없는데 예를들어 2 0 4의 경우를 잘 처리해야 한다. 내가 틀렸을 때는
    그냥 단순히 temp++을 통해 처리했었는데(무조건 temp바로 옆에 다음 옮길 숫자가 있다고 착각) 이렇게하니까 계속 오류가 났었다.

1. **백트래킹**

- 너무나 당연하게도 최대 5번까지 움직일 수 있으니 4방향을 각 재귀마다 돌려봐서 경우의 수를
  전부 계산해야 한다.

### 📌 정리

- 복잡한 규칙이지만 방향 하나만 정확하게 만들어 놓으면 나머지 방향은 자연스럽게 해결
- 백트래킹 주의
