# 📌 문제 설명

[Silver I] 점프 - 1890
[문제 링크](https://www.acmicpc.net/problem/1890)

## 💡 접근 방법

dp를 이용하는 문제였습니다.
최대 경로의 수가 2^63-1이기 때문에 완탐을 이용한다면 시간초과됩니다. DP를 이용해야합니다.

#### 처음 시도한 방식

1. 오른쪽 아래칸 (`[N-1][N-1]`)에서 시작하여 `map`을 역순으로 탐색
2. 각 칸의 숫자만큼 왼쪽(`←`)과 위쪽(`↑`)으로 이동 가능
3. 이동한 위치가 0이면 `true`로 처리
   - `dp`에 `true` 개수를 기록
   - 이미 방문한 좌표(`visited[x][y] === true`)라면 `dp[x][y]` 값을 누적
4. 0이 아니라면 탐색을 중단하고 continue
5. 탐색이 끝난 후 `dp[0][0]` 값을 출력

## ✨ 해결 방법

#### 개선

- 순방향이 더 빠르다! 역방향으로 하면 출발 지점이 거쳐가지 않는 좌표도 방문해야한다.
- 시작점에 1n으로 두고 출발하면, 시작점이 거쳐야하는 좌표의 값은 >= 1n이 된다. 즉 0n이 아니라면 시작점에서 거쳐야하는 지점이다. => visited 필요 없어진다.

  1.  `map[0][0]`에서 시작하여 오른쪽(`→`)과 아래(`↓`)로 이동하며 경로 개수를 누적
  2.  각 칸의 숫자만큼 이동 가능하며, 이동한 위치의 `dp` 값에 현재 위치의 `dp` 값을 더함
  3.  이동한 위치가 `0`이면 탐색 중단
  4.  `dp[N-1][N-1]` 값을 출력

### 📌 정리

- 최대 경로의 수가 2^63임을 캐치해 DP임을 파악해야한다.
- JS 최대 안전 정수는 (2^53 – 1)이다. 최대 경로의 수가 2^63인 걸 고려해 `BigInt`를 사용해야한다.
