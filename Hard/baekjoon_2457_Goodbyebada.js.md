# 📌 문제 설명

## 💡 접근 방법

- 처음 접근 방법

  1.`올해는 4, 6, 9, 11월은 30일까지 있고, 1, 3, 5, 7, 8, 10, 12월은 31일까지 있으며, 2월은 28일까지만 있다.` 를 반영해 각 꽃의 살아있는 날짜를 계산한다.

  2.  가장 오래 살아있는 꽃을 찾아 날짜 정보를 `prevDate`에 담는다.

  3.  `startdate <=   prevEndDate <= endDate` 이거나 `startdate <= prevStartdate <= endDate`인 경우 `prevDate`를 업데이트 하고 꽃의 개수를 세어준다.

  4.  위의 과정을 N번 반복한다.

  5.  `initSm === prevDate[0] &&
initSd === prevDate[1] &&
initLm === prevDate[2] &&
initLd === prevDate[3] - 1`인 경우 answer을 출력한다. 아니라면 0을 출력한다.

### 문제

1. 잘못된 접근 : 가장 오래 살아있는 꽃을 기준으로 꽃의 개수를 세준다면, 꽃이 연속적으로 살아있지 않는다.

```
[3 15 6 30]  // liveDay 긴 B 먼저 선택됨
→ 근데 3/1 ~ 3/14 구간은 비었음
→ 이 시점에서 이미 실패
→ 나중에 A를 선택하고 싶어도 시점이 지나서 고려 대상에서 빠짐
```

빈 구간을 채우기 위해 또 새로운 꽃을 탐색해야한다. -> 브루트포스, 백트래킹에 가깝다.
=> 시간 초과로 이어진다. N= 10^5이기 때문에

2. `initSm === prevDate[0] &&
initSd === prevDate[1] &&
initLm === prevDate[2] &&
initLd === prevDate[3] - 1` prevDate는 마지막으로 선택된 꽃의 날짜이기 때문에 무조건 0이 나올 수 밖에 없는 코드이다.

## ✨ 해결 방법

1. 꽃이 연속적으로 피어있으려면, `빨리 핀 순`으로 정렬한다. 만약 핀 날짜가 같다면 `늦게 지는 순`으로 정렬한다.
   => `꽃의 피는 날짜` 오름차순으로 정렬,`꽃의 지는 날짜` 내림차순으로 정렬

2. `꽃이 지는 날짜`를 기준으로 잡는다.

3. endDay를 정해놓는다. 꽃의 날짜 정보 리스트를 순회한다.
4. 현재 endDay보다 이전에 꽃이 피는지 검사한다.
5. 만약 만족하다면, `flowers[i].start < endDay`을 만족하는 조건 중 가장 길게 피어있는 꽃을 찾는다.
6. endDay를 업데이트한다.
7. 위 과정을 endDay <= `1130`(month \* 100 + day) 일때까지 한다.
8. 만약 만족하는 조건이 없다면 0을 출력한다. -> 빈 공간 발생

### 📌 정리

1. 날짜를 startMonth \* 100 + startDay 로 관리하면 편하다.
2. end day 기준을 잡고 풀면, 굳이 live day를 계산하지 않아도 된다.
3. 그리디로 풀 때 다시 돌아가지 않는지 주의하자.
